#데이터를 제한적으로 접근
#LIFO(Last-In, First-Out) / FILO(First-In, Last-Out)
#문이 하나인 건물에 들어가서 처음 들어간 사람이 제일 마지막에 나온다.
#push() : 데이터를 스택에 넣기       > 데이터를 1,2,3,4,5,6의 순서로 넣었다면
#pop() : 데이터를 스택에서 꺼내기     > 6,5,4,3,2,1의 순서로 꺼내오는 것!

#재귀함수? : 어떠한 것을 정의할 때 자기 자신을 참조하는 것 > 함수 안에서 자기 자신을 호출
#재귀함수는 꼭 끝나는 지점을 정해줘야 무한 루프에 빠지지 않는다.

#스택은 단순하고 빠른 성능을 위해 사용되므로 보통 배열 구조를 활용해 구현하는 것이 일반적
#단점 : 최대 갯수를 미리 정해야한다(파이썬에서는 1000번까지만 호출 가능), 저장 공간의 낭비가 발생할 수 있다(미리 최대 갯수만큼 저장 공간을 확보해야한다.)

#####################################################
#재귀함수
#데이터에 4를 넣었을 때
def recursive(data):
    #만약 데이터가 0보다 작으면
    if data <0:
        #이걸 프린트해라!
        print("ended")
    #아니면 = 0보다 크면
    else:
        #데이터 값을 입력해주고
        print(data)
        #재귀함수를 이용해서 데이터값에 -1을 하여 다시 함수를 호출
        recursive(data-1)
        #쭉이어주다가 데이터값이 -가 되면 아래를 프린트!
        print("returned",data)

print(recursive(4))

#####################################################
#카운트다운
#넘버에 10을 넣었을 때
def count_down(number):
    #만약 넘버가 0보다 작으면 함수가 거기서 끝 
    if number < 0:
        return
    #if구문과는 별개니까 넘버가 0보다 크면 그 수를 프린트하고
    print(number)
    #재귀함수를 이용해 넘버에서 -1을 한 후 다시 함수 호출
    count_down(number-1)

print(count_down(10))

#####################################################
#빈 리스트가 있다.
stack_list = list()

def push(data):
    #이 리스트에 data값을 붙인다
    stack_list.append(data)

#범위를 10 안의 값으로 넣고
for index in range(10):
    #push함수를 돌린다 = 빈 리스트에 append됨
    push(index)

print(stack_list)
#[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

def pop():
    #[-1]은 리스트의 마지막값
    #리스트에서 제일 마지막값을 데이터로 두고
    data = stack_list[-1]
    #이 부분을 지운것을 데이터로 준다.
    del stack_list[-1]
    return data

print(pop())

#####################################################
#팩토리얼 : 1부터 어떤 양의 정수 n까지 정수를 모두 곱한 것